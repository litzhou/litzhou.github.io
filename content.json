{"meta":{"title":"LitZhou's Blog","subtitle":null,"description":null,"author":"LitZhou","url":"http://litzhou.com"},"pages":[{"title":"msg","date":"2017-12-29T06:14:37.000Z","updated":"2017-12-29T06:24:19.426Z","comments":true,"path":"msg/index.html","permalink":"http://litzhou.com/msg/index.html","excerpt":"","text":"给我留言 window.changyan.api.config({ appid: 'cytnHLIj7', conf: 'prod_ff2e472e4db9f2adffaa13bfa76cdd6e' });"},{"title":"开源贡献","date":"2017-12-29T03:10:01.000Z","updated":"2018-03-08T03:47:27.017Z","comments":true,"path":"os/index.html","permalink":"http://litzhou.com/os/index.html","excerpt":"","text":"分布式电商系统 Vacomall ：github 后台管理系统 Layui-Admin：github AdminLTE-admin：github,码云 Extjs4-Shiro-Admin：github,码云 REST-FULL接口框架 restful-api：github App接口：github,码云 MVC框架 FlyMvc：github GO语言 flat-goadmin：github"},{"title":"","date":"2017-12-29T03:09:53.000Z","updated":"2018-03-08T03:50:26.705Z","comments":true,"path":"about/index.html","permalink":"http://litzhou.com/about/index.html","excerpt":"","text":"关于我 卖码为生 常去地方 GitHub @LitZhou 码云 @LitZhou QQ联系我 274410087"}],"posts":[{"title":"项目经理常用工具","slug":"项目经理常用工具","date":"2018-03-08T04:28:48.000Z","updated":"2018-03-08T05:22:12.628Z","comments":true,"path":"2018/03/08/项目经理常用工具/","link":"","permalink":"http://litzhou.com/2018/03/08/项目经理常用工具/","excerpt":"原型设计工具：磨刀：https://modao.cc/ 流程图绘制：Office viso：https://products.office.com/zh-cn/visio/flowchart-software?tab=tabs-1","text":"原型设计工具：磨刀：https://modao.cc/ 流程图绘制：Office viso：https://products.office.com/zh-cn/visio/flowchart-software?tab=tabs-1 项目管理：Office project：https://products.office.com/zh-cn/project?legRedir=true&amp;tab=tabs-1 思维导图：XMind：http://www.xmindchina.net/ BUG管理工具：Debug： https://www.delbug.cn/ 团队协作工具：云竹协作: http://xz.yzsaas.cn/","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://litzhou.com/categories/项目管理/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://litzhou.com/tags/项目管理/"}]},{"title":"Nginx 的主要应该场景总结","slug":"全面解Nginx主要应用场景","date":"2017-12-29T10:52:03.000Z","updated":"2018-03-08T03:36:15.554Z","comments":true,"path":"2017/12/29/全面解Nginx主要应用场景/","link":"","permalink":"http://litzhou.com/2017/12/29/全面解Nginx主要应用场景/","excerpt":"本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。所以还请见谅，同时欢迎留言交流。","text":"本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。所以还请见谅，同时欢迎留言交流。 Nginx能做什么 1.反向代理 2.负载均衡 3.HTTP服务器（包含动静分离） 4.正向代理 以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做 反向代理 反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码12345678910server &#123; listen 80; server_name localhost; client_max_body_size 1024M; location / &#123; proxy_pass http://localhost:8080; proxy_set_header Host $host:$server_port; &#125; &#125; 保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了 负载均衡 负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。 1、RR（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 简单配置1234567891011121314upstream test &#123; server localhost:8080; server localhost:8081;&#125;server &#123; listen 81; server_name localhost; client_max_body_size 1024M; location / &#123; proxy_pass http://test; proxy_set_header Host $host:$server_port; &#125;&#125; 负载均衡的核心代码为1234upstream test &#123; server localhost:8080; server localhost:8081;&#125; 这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。 2、权重 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如 1234upstream test &#123; server localhost:8080 weight=9; server localhost:8081 weight=1; &#125; 那么10次一般只会有1次会访问到8081，而有9次会访问到8080 3、ip_hash 上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。12345upstream test &#123; ip_hash; server localhost:8080; server localhost:8081;&#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。12345upstream backend &#123; fair; server localhost:8080; server localhost:8081;&#125; 5、url_hash（第三方） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法123456upstream backend &#123; hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081;&#125; 以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍 HTTP服务器 Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器1234567891011server &#123; listen 80; server_name localhost; client_max_body_size 1024M; location / &#123; root e:\\wwwroot; index index.html; &#125;&#125; 这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。 动静分离 动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路1234567891011121314151617181920212223242526272829upstream test&#123; server localhost:8080; server localhost:8081; &#125; server &#123; listen 80; server_name localhost; location / &#123; root e:\\wwwroot; index index.html; &#125; # 所有静态请求都由nginx处理，存放目录为html location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123; root e:\\wwwroot; &#125; # 所有动态请求都转发给tomcat处理 location ~ \\.(jsp|do)$ &#123; proxy_pass http://test; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root e:\\wwwroot; &#125; &#125; 这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。1234567891011121314resolver 114.114.114.114 8.8.8.8;server &#123; resolver_timeout 5s; listen 81; access_log e:\\wwwroot\\proxy.access.log; error_log e:\\wwwroot\\proxy.error.log; location / &#123; proxy_pass http://$host$request_uri; &#125;&#125; resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。 最后说两句 Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是1nginx -s reload windows下面就是1nginx.exe -s reload 原文:http://www.admin10000.com/document/12525.html","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://litzhou.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://litzhou.com/tags/Nginx/"}]},{"title":"预计发布的Java 9中，最令人兴奋的特性是什么","slug":"JAVA9的新特性","date":"2017-12-29T09:03:40.000Z","updated":"2018-02-05T06:59:37.534Z","comments":true,"path":"2017/12/29/JAVA9的新特性/","link":"","permalink":"http://litzhou.com/2017/12/29/JAVA9的新特性/","excerpt":"预计发布的Java 9中，最令人兴奋的特性是什么？有关Java9的消息最近显得有些沉寂，不要被它迷惑了。JDK开发者正在努力朝着下一个版本迈进，计划2015年12月前完成所有功能开发。之后，它会经历严格测试和bug修复以准备它的全面上市，按计划会在2016年9月发布。","text":"预计发布的Java 9中，最令人兴奋的特性是什么？有关Java9的消息最近显得有些沉寂，不要被它迷惑了。JDK开发者正在努力朝着下一个版本迈进，计划2015年12月前完成所有功能开发。之后，它会经历严格测试和bug修复以准备它的全面上市，按计划会在2016年9月发布。今天我们已经对Java 9中所期待的特性有了一个很清晰的图景。如果Java 8可以被描述为主要是lambdas表达式、streams和API变化的话，那么Java 9就是关于Jigsaw、额外的实用工具和内部的变化。在这篇文章中，收集了一些我们认为是Java 9中最期待的特性——除了通常的猜测之外，Jigsaw项目，承担了打破JRE并对Java核心组件模块化的使命。这里有一些特性是Java 9中绝对必要了解的，其中的一些已经在早期的发布版本中为你捣鼓做好了准备。 1.Java + REPL = jshell是的。之前我们怀疑Kulla项目是否会在Java 9中准时发布，但现在已得到了官方确认。下一版发布的Java将会有称为jshell的新命令行工具，它会添加本地支持和以Java方式对REPL（交互式解释器）进行推广。意思是说，如果你想只运行几行Java代码，你不必把它包装进一个单独的工程或者方法。噢，你可以忘掉那些分号了：123-&gt; 2 + 2| 表达式的值是4| 将临时变量$1的类型设为int 还有一些像REPL加载项一样的替代品会增加到流行的IDE和解决方案中，就像Java REPL网页控制台。但目前为止，还没有官方的或者合适的方式来这么做。jshell在早期的版本中已经可以用了，等着你给它来个测试运行。 2、微基准测试要来了 由Alexey Shipilev开发的Java微基准测试套件（Java Microbenchmarking Harness）正在其进化的下一阶段，并加入Java作为官方基准解决方案。我们真的很喜欢在Takipi做基准，所以一套标准化的执行方式是我们期待的。 JHM是一组用来编译、运行和分析nano/micro/milli/macro基准的套件。当涉及到精确基准评估，对结果产生很大影响的能力将备受关注，比如预热时间和优化。当你以微秒或纳秒计时的情况下尤其如此。所以，如果你想要更加精确的结果来帮助跟踪基准以做出正确的决定，JMH是你的最佳选择——并且现在它已经成为Java 9的同义词了。 3、G1会成为新的默认垃圾收集器吗？ 我们经常听说的一个误解是：Java只有一个垃圾收集器，而事实上它有4个。Java 9中，仍有一个运行提议，关于替换由Java 7引入的G1默认垃圾收集器（并行/吞吐量收集）的讨论。不同收集器之间差别精简概述，可以查看这篇里的文章。 通常来说，G1被设计来更好地支持大于4GB的堆，并且不会造成频繁的GC暂停，但当暂停发生时，往往会处理更长时间。最近我们和Outbrain的性能专家Haim Yadid讨论了关于GC的方方面面，来帮助你了解更多各收集器之间不同的权衡。同样，如果你想要深入了解相关讨论，那么hotspot-dev和jdk9-dev的邮件组是个开始学习不错的地方。 4、未来是HTTP 2.0 官方的HTTP 2.0标准是几个月之前被批准的，基于Google的SPDY算法构建。SPDY已经展示了相对HTTP 1.1巨大的速度提升，范围在11.81%到47.7%之间，并且它已经存在于大多数现代的浏览器中了。Java 9将全面支持HTTP 2.0，并且为Java配备一个全新的HTTP客户端来替代HttpURLConnection，并且同时还实现HTTP 2.0和websockets。 5、进程API得到了巨大的推动 到目前为止，通过Java来控制和管理操作系统进程能力有限。例如在早期版本的Java中，为了做一些简单的事情，像得到进程PID，要么访问本机代码，要么用某种神奇的临时解决方法。此外，还可能需要一个对于每个平台提供不同实现来保证你得到正确的结果。 在Java 9中，除了获取Linux PID的代码，现在都像这样来获取： 1234567891011public static void main(String[] args) throws Exception &#123; Process proc = Runtime.getRuntime().exec(new String[]&#123; \"/bin/sh\", \"-c\", \"echo $PPID\" &#125;); if (proc.waitFor() == 0) &#123; InputStream in = proc.getInputStream(); int available = in.available(); byte[] outputBytes = new byte[available]; in.read(outputBytes); String pid = new String(outputBytes); System.out.println(\"Your pid is \" + pid); &#125;&#125; 转向像这样的代码（同样也支持所有的操作系统）：1System.out.println(\"Your pid is\" + Process.getCurrentPid()); 这一更新将扩展Java与操作系统交互的能力：全新的直接操作PID、进程名和状态的方法，操作JVM线程和进程等等能力。你不会在Java 9中见到什么？ 我们以为两个有趣的特性会作为即将到来的Java发布版本中的一部分——但现在我们知道它们将不会出现在这次发布的版本。 1、一个标准的轻量级JSON API 在我们进行的一项对350名开发人员的调查中，JSON API就像Jigsaw一样被大肆宣传，但看起来它好像没在发布版本中，原因可能是资金问题。Mark Reinhold，Java平台的首席架构师，在JDK 9的邮件列表中写到：“这个JEP对于平台来说是个有益的补充，但长远来看，考虑到资金的因素以及Oracle资助的其它特性，它并不如其它特性一样重要。我们考虑可能在JDK 10或者之后的版本再发布这个JEP。” 2、金钱和货币API 有一条新闻，似乎看起来金钱和货币API也缺少Oracle的支持。这是我们从Anatole Tresch那里得到的答案，这个API的产品推广师：@tkfxin 目前不会。从Oracle那里没得到支持。取而代之的，我们将提高Java EE支持并且spring也将支持它 :)– Anatole Tresch (@atsticks) 2015年6月16日 我们遗漏了什么吗？请在下面的评论区告诉我们吧。没有空闲时间？来看看何时以及为何在产品中代码会出现失败中断。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/tags/Java/"}]},{"title":"JAVA 代码性能优化总结","slug":"35个Java代码性能优化总结","date":"2017-12-29T08:43:38.000Z","updated":"2018-03-08T03:34:58.011Z","comments":true,"path":"2017/12/29/35个Java代码性能优化总结/","link":"","permalink":"http://litzhou.com/2017/12/29/35个Java代码性能优化总结/","excerpt":"代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。","text":"代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是： 1、减小代码的体积 2、提高代码运行的效率 代码优化细节 1、尽量指定类、方法的final修饰符 带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。 2、尽量重用对象 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流 Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：12for (int i = 0; i &lt; list.size(); i++)&#123;...&#125; 建议替换为：12for (int i = 0, int length = list.size(); i &lt; length; i++)&#123;...&#125; 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建 例如：123456String str = \"aaa\";if (i == 1)&#123;list.add(str);&#125; 建议替换为：12345678if (i == 1)&#123;String str = \"aaa\";list.add(str);&#125; 7、慎用异常 异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层 除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： （1）StringBuilder() // 默认分配16个字符的空间 （2）StringBuilder(int size) // 默认分配size个字符的空间 （3）StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间 （2）把原来的4096个字符拷贝到新的的字符数组中去 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令 11、乘法和除法使用移位操作 例如：123456789for (val = 0; val &lt; 100000; val += 5)&#123;a = val * 8;b = val / 2;&#125; 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：123456789for (val = 0; val &lt; 100000; val += 5)&#123;a = val &lt;&lt; 3;b = val &gt;&gt; 1;&#125; 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用 例如： 1234567for (int i = 1; i &lt;= count; i++)&#123;Object obj = new Object();&#125; 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： 1Object obj = null;for (int i = 0; i &lt;= count; i++) &#123; obj = new Object(); &#125; 这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList 14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销 15、不要将数组声明为public static final 因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变 16、尽量在合适的场合使用单例 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量 要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：123456public class A&#123; private static B b = new B();&#125; 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话 为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历 这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：123456789if (list instanceof RandomAccess)&#123; for (int i = 0; i &lt; list.size(); i++)&#123;&#125;&#125;else&#123;Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext())&#123;iterator.next()&#125;&#125; foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法 这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名 这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类 这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射 关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作 带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList 这个，理解ArrayList和LinkedList的原理就知道了 27、不要让public方法中有太多的形参 public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 2、参数太多势必导致方法调用的出错概率增加 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参 28、字符串变量和字符串常量equals的时候将字符串常量写在前面 这是一个比较常见的小技巧了，如果有以下代码：123456String str = \"123\";if (str.equals(\"123\")) &#123;...&#125; 建议修改为：12345678String str = \"123\";if (\"123\".equals(str))&#123;...&#125; 这么做主要是可以避免空指针异常 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者 平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。 在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：123456789101112int i = 2;if (i == 1)&#123;...&#125;else&#123;...&#125; C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：1int i = 2;if (i = 1) &#123; ... &#125;else&#123; ... &#125; 万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：1int i = 2;if (1 == i) &#123; ... &#125;else&#123; ... &#125; 这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。 但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法 看一下对数组使用toString()打印出来的是什么：1234567public static void main(String[] args)&#123; int[] is = new int[]&#123;1, 2, 3&#125;;System.out.println(is.toString());&#125; 结果是：[I@18a992f本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString()方法。 31、不要对超出范围的基本数据类型做向下强制转型这绝不会得到想要的结果：12345678910public static void main(String[] args)&#123; long l = 12345678901234L;int i = (int)l;System.out.println(i);&#125; 我们可能期望得到其中的某几位，但是结果却是： 1942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010 一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 0111 0011 1100 1110 0010 1111 1111 0010 这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论： 1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f = 3.5f” 2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢 把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args)&#123; int loopTime = 50000;Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)&#123;String str = String.valueOf(i);&#125;System.out.println(\"String.valueOf()：\" + (System.currentTimeMillis() - startTime) + \"ms\");startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)&#123;String str = i.toString();&#125;System.out.println(\"Integer.toString()：\" + (System.currentTimeMillis() - startTime) + \"ms\");startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++)&#123;String str = i + \"\";&#125;System.out.println(\"i + \\\"\\\"：\" + (System.currentTimeMillis() - startTime) + \"ms\");&#125; 运行结果为：String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： 1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 2、Integer.toString()方法就不说了，直接调用了 3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 34、使用最有效率的方式去遍历Map 遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：123456789101112131415161718192021public static void main(String[] args)&#123;HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();hm.put(\"111\", \"222\");Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext())&#123;Map.Entry&lt;String, String&gt; entry = iter.next();System.out.println(entry.getKey() + \"\\t\" + entry.getValue());&#125;&#125; 如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet();”会比较合适一些 35、对资源的close()建议分开操作 意思是，比如我有这么一段代码：12345678910111213try&#123;XXX.close();YYY.close();&#125;catch (Exception e)&#123;...&#125; 建议修改为：1try&#123; XXX.close(); &#125;catch (Exception e) &#123; ... &#125;try&#123; YYY.close(); &#125;catch (Exception e) &#123; ... &#125; 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。 原文地址: http://www.admin10000.com/document/6785.html","categories":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/tags/Java/"}]},{"title":"JAVA 8 十大新特性详解","slug":"JAVA8十大新特性详解","date":"2017-12-25T10:07:43.000Z","updated":"2018-03-08T03:32:13.482Z","comments":true,"path":"2017/12/25/JAVA8十大新特性详解/","link":"","permalink":"http://litzhou.com/2017/12/25/JAVA8十大新特性详解/","excerpt":"–接口中的方法都是抽象的吗？–NO,今天在翻看jdk的java.util.Comparator接口的时候发现了下面这段代码 12345678910/** Returns a comparator that imposes the reverse ordering of this * comparator. * * @return a comparator that imposes the reverse ordering of this * comparator. * @since 1.8 */ default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this); &#125;","text":"–接口中的方法都是抽象的吗？–NO,今天在翻看jdk的java.util.Comparator接口的时候发现了下面这段代码 12345678910/** Returns a comparator that imposes the reverse ordering of this * comparator. * * @return a comparator that imposes the reverse ordering of this * comparator. * @since 1.8 */ default Comparator&lt;T&gt; reversed() &#123; return Collections.reverseOrder(this); &#125; 我擦，什么情况？现在带你领略下Java8的新特性： 一、接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： 123456interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125; &#125; Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 12345678Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125; &#125;; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。 二、Lambda 表达式首先看看在老版本的Java中是如何排列字符串的： 1234567List&lt;String&gt; names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\"); Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125; &#125;); 只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a); &#125;); 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： 三、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。示例如下：1234567@FunctionalInterface interface Converter&lt;F, T&gt; &#123; T convert(F from); &#125; Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。四、方法与构造函数引用前一节中的代码还可以通过静态方法引用来表示：123Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(\"123\"); System.out.println(converted); // 123 Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：123converter = something::startsWith; String converted = converter.convert(\"Java\"); System.out.println(converted); // \"J\" 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类123456789class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; &#125; 接下来我们指定一个用来创建Person对象的对象工厂接口：123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName); &#125; 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：12PersonFactory&lt;Person&gt; personFactory = Person::new; Person person = personFactory.create(\"Peter\", \"Parker\"); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 五、Lambda 作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 六、访问局部变量我们可以直接在lambda表达式中访问外层的局部变量：1234final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：1234int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：1234int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); num = 3; 在lambda表达式中试图修改num同样是不允许的。 七、访问对象字段与静态变量和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：1234567891011121314class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125; &#125; 八、访问接口的默认方法还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：1Formula formula = (a) -&gt; sqrt( a * 100); Built-in Functional InterfacesJDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 Predicate接口Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：1234567Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0; predicate.test(\"foo\"); // true predicate.negate().test(\"foo\"); // false Predicate&lt;Boolean&gt; nonNull = Objects::nonNull; Predicate&lt;Boolean&gt; isNull = Objects::isNull; Predicate&lt;String&gt; isEmpty = String::isEmpty; Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Function 接口Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：123Function&lt;String, Integer&gt; toInteger = Integer::valueOf; Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); backToString.apply(\"123\"); // \"123\" Supplier 接口Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数12Supplier&lt;Person&gt; personSupplier = Person::new; personSupplier.get(); // new Person Consumer 接口Consumer 接口表示执行在单个参数上的操作。12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(\"Hello, \" + p.firstName); greeter.accept(new Person(\"Luke\", \"Skywalker\")); Comparator 接口Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：12345Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName); Person p1 = new Person(\"John\", \"Doe\"); Person p2 = new Person(\"Alice\", \"Wonderland\"); comparator.compare(p1, p2); // &gt; 0 comparator.reversed().compare(p1, p2); // &lt; 0 Optional 接口Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。12345Optional&lt;String&gt; optional = Optional.of(\"bam\"); optional.isPresent(); // true optional.get(); // \"bam\" optional.orElse(\"fallback\"); // \"bam\" optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // \"b\" Stream 接口java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。首先看看Stream是怎么用，首先创建实例代码的用到的数据List：123456789List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;(); stringCollection.add(\"ddd2\"); stringCollection.add(\"aaa2\"); stringCollection.add(\"bbb1\"); stringCollection.add(\"aaa1\"); stringCollection.add(\"bbb3\"); stringCollection.add(\"ccc\"); stringCollection.add(\"bbb2\"); stringCollection.add(\"ddd1\"); Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：Filter 过滤过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。12345stringCollection .stream() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println); // \"aaa2\", \"aaa1\" Sort 排序排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。123456stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println); // \"aaa1\", \"aaa2\" 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：12System.out.println(stringCollection); // ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map 映射中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。123456stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println); // \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\" Match 匹配Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。123456789101112131415boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(\"a\")); System.out.println(anyStartsWithA); // true boolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(\"a\")); System.out.println(allStartsWithA); // false boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(\"z\")); System.out.println(noneStartsWithZ); // true Count 计数计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。123456long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(\"b\")) .count(); System.out.println(startsWithB); // 3 Reduce 规约这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：1234567Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + \"#\" + s2); reduced.ifPresent(System.out::println); // \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\" 并行Streams前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。下面的例子展示了是如何通过并行Stream来提升性能：首先我们创建一个没有重复元素的大表：123456int max = 1000000; List&lt;String&gt; values = new ArrayList&lt;&gt;(max); for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString()); &#125; 然后我们计算一下排序这个Stream要耗时多久，串行排序：1234567long t0 = System.nanoTime(); long count = values.stream().sorted().count(); System.out.println(count); long t1 = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(\"sequential sort took: %d ms\", millis)); // 串行耗时: 899 ms 并行排序：1234567long t0 = System.nanoTime(); long count = values.parallelStream().sorted().count(); System.out.println(count); long t1 = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(\"parallel sort took: %d ms\", millis)); // 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。Map前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。12345Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, \"val\" + i); &#125; map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。下面的例子展示了map上的其他有用的函数：12345678map.computeIfPresent(3, (num, val) -&gt; val + num); map.get(3); // val33 map.computeIfPresent(9, (num, val) -&gt; null); map.containsKey(9); // false map.computeIfAbsent(23, num -&gt; \"val\" + num); map.containsKey(23); // true map.computeIfAbsent(3, num -&gt; \"bam\"); map.get(3); // val33 接下来展示如何在Map里删除一个键值全都匹配的项：1234map.remove(3, \"val3\"); map.get(3); // val33 map.remove(3, \"val33\"); map.get(3); // null 另外一个有用的方法1map.getOrDefault(42, \"not found\"); // not found 对Map的元素做合并也变得很容易了：1234map.merge(9, \"val9\", (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9 map.merge(9, \"concat\", (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9concat Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 九、Date APIJava 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： Clock 时钟Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。1234lock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。12345678System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(\"Europe/Berlin\"); ZoneId zone2 = ZoneId.of(\"Brazil/East\"); System.out.println(zone1.getRules()); System.out.println(zone2.getRules()); // ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00] LocalTime 本地时间LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：1234567891011121314151617181920212223242526LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。[java] view plain copyLocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter); System.out.println(leetTime); // 13:37 LocalDate 本地日期LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。[java] view plain copyLocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek(); System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：12345678910111213141516DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN); LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter); System.out.println(xmas); // 2014-12-24 LocalDateTime 本地日期时间LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。[java] view plain copyLocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。12345Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：123456DateTimeFormatter formatter = DateTimeFormatter .ofPattern(\"MMM dd, yyyy - HH:mm\"); LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。关于时间日期格式的详细信息：http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html 十、Annotation 注解在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。首先定义一个包装类Hints注解用来放置一组具体的Hint注解：1234567@interface Hints &#123; Hint[] value(); &#125; @Repeatable(Hints.class) @interface Hint &#123; String value(); &#125; Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。例 1: 使用包装类当容器来存多个注解（老方法）12@Hints(&#123;@Hint(\"hint1\"), @Hint(\"hint2\")&#125;) class Person &#123;&#125; 例 2：使用多重注解（新方法）123@Hint(\"hint1\") @Hint(\"hint2\") class Person &#123;&#125; 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：123456Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2 Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。另外Java 8的注解还增加到两种新的target上了：12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;) @interface MyAnnotation &#123;&#125; 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。","categories":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/tags/Java/"}]},{"title":"JAVA 高级开发工程师面试考纲","slug":"Java高级开发工程师面试考纲","date":"2017-12-25T07:12:46.000Z","updated":"2018-03-08T03:35:33.937Z","comments":true,"path":"2017/12/25/Java高级开发工程师面试考纲/","link":"","permalink":"http://litzhou.com/2017/12/25/Java高级开发工程师面试考纲/","excerpt":"当前，市面上有《Java XX宝典》类似的图书，而且图书中的内容都着重在讲解Java最为基础的部分，最严重的是，里面有着大量错误的内容，极具误导性。另外，网上也有各种各样的Java面试题，很多也是着重在Java语言基础上。实际上，如果要应聘高级开发工程师职务，仅仅懂得Java的基础知识是远远不够的，还必须懂得常用数据结构、算法、网络、操作系统等知识。因此本文不会讲解具体的技术，笔者综合自己应聘各大公司的经历，整理了一份大公司对Java高级开发工程师职位的考核纲要，希望可以帮助到需要的人。","text":"当前，市面上有《Java XX宝典》类似的图书，而且图书中的内容都着重在讲解Java最为基础的部分，最严重的是，里面有着大量错误的内容，极具误导性。另外，网上也有各种各样的Java面试题，很多也是着重在Java语言基础上。实际上，如果要应聘高级开发工程师职务，仅仅懂得Java的基础知识是远远不够的，还必须懂得常用数据结构、算法、网络、操作系统等知识。因此本文不会讲解具体的技术，笔者综合自己应聘各大公司的经历，整理了一份大公司对Java高级开发工程师职位的考核纲要，希望可以帮助到需要的人。 1 Java基础 1.1 Collection和Map (1)掌握Collection和Map的继承体系。 (2)掌握ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、TreeMap、HashTable的特点和实现原理。 (3)掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。 1.2 IO (1)掌握InputStream、OutputStream、Reader、Writer的继承体系。 (2)掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。 (3)掌握NIO实现原理及使用方法。 1.3 异常 (1)掌握Throwable继承体系。 (2)掌握异常工作原理。 (3)了解常见受检异常(比如FileNotFoundException)、非受检异常(比如NullPointerException)和错误(比如IOError)。 1.4 多线程 (1)掌握Executors可以创建的三种(JAVA8增加了一种，共四种)线程池的特点及适用范围。 (2)掌握多线程同步机制，并熟练运用。 1.5 Socket (1)掌握Socket通信原理。 (2)熟练使用多线程结合Socket进行编程。 2 Java虚拟机 2.1 JVM内存区域划分 (1)掌握程序计数器、堆、虚拟机栈、本地方法栈、方法区（JAVA8已移除）、元空间（JAVA8新增）的作用及基本原理。 (2)掌握堆的划分：新生代（Eden、Survivor1、Survivor2）和老年代的作用及工作原理。 (3)掌握JVM内存参数设置及调优。 2.2 类加载 (1)掌握类的加载阶段：加载、链接（验证、准备、解析）、初始化、使用、卸载。 (2)掌握类加载器分类及其应用：启动类加载器、扩展类加载器、应用程序类加载器、自定义加载器。 3 J2EE (1) 掌握JSP内置对象、动作及相关特点和工作原理。 (2) 掌握Servlet的特点和工作原理。 (3) 掌握Spring框架的IOC和AOP实现原理（反射和动态代理）。 (4) 至少掌握一个MVC框架（Spring MVC，Struts等）的工作原理，并熟练运用。 (5) 至少掌握一个ORM框架(Hibernate，MyBatis等)的工作原理，并熟练运用。 4 数据结构与算法 (1)掌握线性表和树的特点并熟练运用。 (2)掌握常用排序和查找算法：插入排序(直接插入排序、希尔排序)、选择排序(直接选择排序、堆排序)、交换排序(冒泡排序、快速排序)、归并排序，顺序查找、二分查找、哈希查找。 (3) 熟练运用常见排序和查找算法思想解决编程问题。 (4)了解几大基本算法：贪心算法、分治策略、动态规划。 5 计算机网络 (1)掌握网络的分层结构，及每层的功能特点。 (2)掌握TCP/IP的通信原理(三次握手、四次挥手) 6 数据库 (1)掌握复杂的SQL语句编写。 (2)掌握数据库的优化（SQL层面和表设计层面）。 (3)至少掌握一款数据库产品。 (4)熟悉高并发、大数据情况下的数据库开发。 7 Web技术 (1)掌握AJAX的工作原理。 (2)至少熟悉一款JS框架(比如JQuery)。 8 设计模式 (1)熟悉常见的设计模式。 (2)会将设计模式理论应用到实际开发中。 9 Linux (1)熟练运用Linux常见命令。 (2)熟悉Linux操作系统基本概念及特点。 (3)熟悉Shell脚本。 10 操作系统 (1)掌握操作系统的进程管理。 (2)了解操作系统的I/O。 11 正则表达式 (1)掌握常见正则表达式符号。 (2)熟练运用正则表达式解决实际问题(比如匹配电话号码、邮箱、域名等)。","categories":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/tags/Java/"}]},{"title":"MySQL 数据库使用笔记","slug":"MYSQL数据库笔记","date":"2017-12-25T04:40:23.000Z","updated":"2018-03-08T03:36:00.883Z","comments":true,"path":"2017/12/25/MYSQL数据库笔记/","link":"","permalink":"http://litzhou.com/2017/12/25/MYSQL数据库笔记/","excerpt":"常见错误解决方案：1、mysql服务启动不了，进程意外终止 1067 错误显示：can not connect to mysql server on local hosts(1061) 解决方法：原来是我傻逼把原来的MySQL数据库给删掉了2、服务已经启动，但是输入密码时 进不去错误显示：ERROR 1045 :Access denied for user’root’@’locahost’解决方法：http://blog.sina.com.cn/s/blog_759a5a7c01017dj0.html3、默认端口号：3306","text":"常见错误解决方案：1、mysql服务启动不了，进程意外终止 1067 错误显示：can not connect to mysql server on local hosts(1061) 解决方法：原来是我傻逼把原来的MySQL数据库给删掉了2、服务已经启动，但是输入密码时 进不去错误显示：ERROR 1045 :Access denied for user’root’@’locahost’解决方法：http://blog.sina.com.cn/s/blog_759a5a7c01017dj0.html3、默认端口号：3306 MySQL语句规范：关键字和函数名称全部大写；数据库名称、表的名称、字段的名称全部小写；SQL语句必须以分好结尾。加中括号表示可以省略 显示当前版本；1mysql&gt;SELECT VERSION(); 显示当前时间；1mysql&gt;SELECT NOW(); 显示当前用户；1mysql&gt;SELECT USER(); 修改原始密码：打开命令提示符界面, 执行命令: mysqladmin -u root -p password 新密码执行后提示输入旧密码完成密码修改, 当旧密码为空时直接按回车键确认即可。 开始：//创建数据库：12345MySQL&gt;CREATE DATABASE (IF NOT EXISTS) case;``` //显示已经存在的数据库；``` MySQL&gt;SH0W DATABASES; //重命名数据库名称先关闭数据库，然后找到文件夹所在目录，更改文件夹名称。//显示某个数据库；1MySQL&gt;SHOW CREATE DATABASE case; //更改数据库编码为utf8;1MySQL&gt;ALTER DATABASE case CHATACTER SET=utf8; //删除数据库：1MySQL&gt;DROP DATABASE case; 修改和删除 修改默认值：12ALTER TABLE TB_NAME ALTER 字段名 SET DEFAULT 默认值;ALTER TABLE TB_NAME ALTER 字段名 DROP DEFAULT ; 修改表名1ALTER TABLE 表名 RENAME TO 新名; 修改字段名1ALTER TABLE 表名 CHANGE 旧字段 新字段 新字段数据类型 修改字段数据类型1ALTER 表名 MODIFY 属性名 数据类型 增加字段1ALTER TABLE 表名 ADD 字段1 字段1的条件 ［FIRST | AFTER 字段2］; 删除字段1ALTER TABLE 表名 DROP 字段; 修改字段的排列位置:1ALTER TABLE 表名 MODIFY 字段1 字段1数据类型 FIRST｜AFTER 字段2; 更改表的存储引擎:1ALTER TABLE 表名 ENGINE＝引擎名 添加主键约束：1ALTER TABLE 表名 ADD PRIMARY KEY (外键名) 删除外键约束:1ALTER TABLE 表名 DROP FOREIGN KEY (外键别名) 修改数据表的名称：1ALTER TABLE table_name RENAME TO new_table_name 删除记录：1delete from users where id=1； 修改记录：12update 表名 set 字段=新值 where 条件;update users set id=1 whers sex=1; 表字段的修改：增加字段12ALTER table tb_name ADD column_name 属性 位置; //增加一个字段，默认为空alter table user add COLUMN new2 VARCHAR(20) NOT NULL; //增加一个字段，默认不能为空 删除字段12alter table user DROP COLUMN new2; //删除一个字段alter table user DROP column1,column2; //删除多列 修改一个字段12alter table user MODIFY new1 VARCHAR(10); //修改一个字段的类型alter table user CHANGE new1 new4 int; //修改一个字段的名称，此时一定要重新指定该字段的类型 第二章：1、数据类型：整型： TINYINT -2^7-&gt;2^7-1SMALLINT -2^15-&gt;2^15-1MEDIUMINT -2^23-&gt;2^23-1INT -2^31-&gt;2^31-1BIGINT -2^63-&gt;2^63-1 浮点型： FLOAT[(M,D)] m代表总位数，d代表小数点后位数DOUBLE[(M,D)] 时间日期型：(了解) YEAR 1个字节TIME 3DATE 3DATETIME 8TIMESTAMP 4 字符型： CHAR(M) 0&lt;=M&lt;=255VARCHAR(M)TINYTEXTTEXTMEDIUMTEXTLONGTEXTENUM(‘value1,’value2’…)SET(‘value1’,’value2’,,,) 2、数据表的操作打开数据库：1USE test(数据库名称） 创建数据表：1CREATE TABLE (IF NOT EXISTS) table_name&lt;数据表名字&gt;(column_name&lt;根据项目大小确定的列名&gt;data_type&lt;数据类型&gt;,..) 123456USE TEST;CREATE TABLE tb1(username VARCHAR(20),age TINYINT UNSIGNED,&lt;unsigned意思是不要负数&gt;salary FLOAT(8,2) UNSIGNED &lt;float(8,2)的意思是总共有8位数，其中小数点后有2位)&gt;); 查看数据表列表1SHOW TABLES FROM test； 查看数据表结构1SHOW COLUMNS FROM TB1; 插入记录INSERT12INSERT [INTO] tb1_name [(col_name,，，)] VALUES(val,,,)INSERT TB1 (username ,salary) VALUES (&apos;tom&apos;,26,919.3); 插入的也可以是算式比如：33-2 或者函数式：MD5(‘342’)也可以一次插入多条记录，记录间用，分开就行。 记录查找SELECT1SELECT * FROM TB1_NAME 3、空值与非空 NULL 字段值可以为空 NOT NULL 字段禁止为空 创建表，设定某些量空与非空12345&gt;CREATE TABLE TB2(&gt;username VARCHAR(20) NOT NULL,&gt;age TINYINT UNSIGNED NULL,&gt;);&gt;INSERT TB2 VALUES(NULL,20); &lt;将报错说username不可为空&gt; 4、自动编号（AUTO_INCREMENT)不能用char类型 自动编号，且需与主键组合使用默认情况下，起始值为1，每次的增量为1； 5、主键约束(PRIMARY KEY) 每张数据表只存在一个主键主键保证记录的唯一性主键自动为not null 多个字段联合主键：PRIMARY KEY(username，age);12&gt;CREATE TABLE TB2(&gt;id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, AUTO_INCREMENT(自动递增)必须和PRIMARY KRY一起使用，而PRIMARY KEY则不一定要和AUTO_INCREMENT一起使用123&gt;username VARCHAR(20) NOT NULL,&gt;);&gt;SHOW COLUMNS FROM TB3; 6、唯一约束(UNIQUE KEY)唯一约束唯一约束可以保证记录的唯一性唯一约束的字段可以为NULL每张数据表可以存在多个唯一约束与主键的区别：一张数据表只能有一个主键，而UNIQUE KEY可以有多个可以NULL12345&gt;CREATE TABLE TB4(&gt;id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,&lt;自动编号字段&gt;&gt;username VARCHAR(20) NOT NULL UNIQUE KEY,&gt;age TINYINT UNSIGNED&gt;); 插入记录：INSERT TB4(username，age) VALUES(‘TOM’,23);当再次写入同样的记录时，将提示错误，因为username用了unique约束。可想而知这个约束在数据表里可以有多个。 7、默认约束(DEFAULT) 默认值当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。12345&gt;CREATE TABLE TB5(&gt;id SAMLLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,&gt;username VARCHAR(20) NOT NULL UNIQUE KEY,&gt;sex ENUM(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) DEFAULT &apos;3&apos;&gt;); 验证：1INSERT TB5(username)VALUES(&apos;TOM&apos;); 将发现自动给sex赋值3了。 8、外键约束 要求：表与表之间的链接父表和子表必须使用相同的储存引擎（InnoDB)，而禁止使用临时表：外键列和参照列必须具有相识的数据类型。其中数字的长度或是否有符号位必须相同；而字符 的长度则可以不同外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。 1234CREATE TABLE provinces(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,pname VARCHAR(20) NOT NULL); 查看数据表的引擎：1show create table provinces; 1234567CREATE TABLE users(id SMALLINT UNSIGNED PRIMARU KEY AUTO_INCREMENT,username VARCHAR(10) NOT NULL,//添加省份的话可以不用添加字段，只要添加关系表省份的编号就行pid SMALLINT UNSIGNED, FOREIGN KEY(pid)REFERENCES provinces(id)); 查看索引：12SHOW INDEXES FROM provinces\\G;SHOW INDEXES FROM users\\G; 外键约束的参数： CASCADE：从父表删除或更新且自动删除或更新字表中匹配的行SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL，如果使用该选项，必须保证 子表列没有指定NOT NULLTESTRICT(约束、限制)：拒绝对父表的删除或更新操作NO ACTION：标准的SQL的关键字，在MySQL中RESTRICT相同。 为自动编号的字段赋值 可以书写成default 或者null创建表：1234567CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(20) NOT NULL,password VARCHAR(32) NOT NULL DEFAULT 123,age TINYINT UNSIGNED NOT NULL,sex BOOLEAN); 插入记录：1INSERT users VALUES(NULL,&apos;Jack&apos;,159357,20,1);","categories":[{"name":"DB","slug":"DB","permalink":"http://litzhou.com/categories/DB/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://litzhou.com/tags/MySQL/"}]},{"title":"Linux 常用命令总结","slug":"Linux常用命令","date":"2017-12-23T06:07:06.000Z","updated":"2018-03-08T03:35:44.009Z","comments":true,"path":"2017/12/23/Linux常用命令/","link":"","permalink":"http://litzhou.com/2017/12/23/Linux常用命令/","excerpt":"常用指令ls 显示文件或目录12-l 列出文件详细信息l(list)-a 列出当前目录下所有文件及目录，包括隐藏的a(all)","text":"常用指令ls 显示文件或目录12-l 列出文件详细信息l(list)-a 列出当前目录下所有文件及目录，包括隐藏的a(all) mkdir 创建目录 1-p 创建目录，若无父目录，则创建p(parent) cd 切换目录 touch 创建空文件 echo 创建带有内容的文件。 cat 查看文件内容 cp 拷贝 mv 移动或重命名 rm 删除文件 12-r 递归删除，可删除子目录及文件-f 强制删除 find 在文件系统中搜索某文件 wc 统计文本中行数、字数、字符数 grep 在文本文件中查找某个字符串 rmdir 删除空目录 tree 树形结构显示目录，需要安装tree包 pwd 显示当前目录 ln 创建链接文件 more、less 分页显示文本文件内容 head、tail 显示文件头、尾内容 ctrl+alt+F1 命令行全屏模式 系统管理命令stat 显示指定文件的详细信息，比ls更详细 who 显示在线登陆用户 whoami 显示当前操作用户 hostname 显示主机名 uname 显示系统信息 top 动态显示当前耗费资源最多进程信息 ps 显示瞬间进程状态 ps -aux du 查看目录大小 du -h /home带有单位显示目录信息 df 查看磁盘大小 df -h 带有单位显示磁盘信息 ifconfig 查看网络情况 ping 测试网络连通 netstat 显示网络状态信息 man 命令不会用了，找男人 如：man ls clear 清屏 alias 对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit kill 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。 打包压缩相关命令gzip： bzip2： tar: 打包压缩 123456-c 归档文件-x 压缩文件-z gzip压缩文件-j bzip2压缩文件-v 显示压缩或解压缩过程 v(view)-f 使用档名 例：123tar -cvf /home/abc.tar /home/abc 只打包，不压缩tar -zcvf /home/abc.tar.gz /home/abc 打包，并用gzip压缩tar -jcvf /home/abc.tar.bz2 /home/abc 打包，并用bzip2压缩 当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“c” 换成“x” 就可以了。 关机/重启机器shutdown123-r 关机重启-h 关机不重启now 立刻关机 halt 关机 reboot 重启 Linux管道将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。 例：1grep -r &quot;close&quot; /home/* | more //在home目录下所有文件中查找，包括close的文件，并分页输出。 Linux软件包管理dpkg (Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。 比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。12sudo dpkg -i tree_1.5.3-1_i386.deb //安装软件sudo dpkg -r tree //卸载软件 注：将tree.deb传到Linux系统中，有多种方式。VMwareTool，使用挂载方式；使用winSCP工具等；APT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。 依然以tree为例 1234sudo apt-get install tree 安装treesudo apt-get remove tree 卸载treesudo apt-get update 更新软件sudo apt-get upgrade 将.rpm文件转为.deb文件 .rpm为RedHat使用的软件格式。在Ubuntu下不能直接使用，所以需要转换一下。1sudo alien abc.rpm vim使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 命令模式下： :q 退出 :q! 强制退出 :wq 保存并退出 :set number 显示行号 :set nonumber 隐藏行号 /apache 在文档中查找apache 按n跳到下一个，shift+n上一个 yyp 复制光标所在行，并粘贴 h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→) 用户及用户组管理/etc/passwd 存储用户账号 /etc/group 存储组账号 /etc/shadow 存储用户账号的密码 /etc/gshadow 存储用户组账号的密码 useradd 用户名 userdel 用户名 adduser 用户名 groupadd 组名 groupdel 组名 passwd root 给root设置密码 su root su - root /etc/profile 系统环境变量 bash_profile 用户环境变量 .bashrc 用户环境变量 su user 切换用户，加载配置文件.bashrc su - user 切换用户，加载配置文件/etc/profile ，加载bash_profile 文件的用户及用户组sudo chown [-R] owner[:group] {File|Directory} 例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop 要想切换此文件所属的用户及组。可以使用命令。 sudo chown root:root jdk-7u21-linux-i586.tar.gz 文件权限管理三种基本权限 R 读 数值表示为4 W 写 数值表示为2 X 可执行 数值表示为1 如图所示，jdk-7u21-linux-i586.tar.gz文件的权限为-rw-rw-r– -rw-rw-r–一共十个字符，分成四段。 第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录 第二三四个字符“rw-”表示当前所属用户的权限。 所以用数值表示为4+2=6 第五六七个字符“rw-”表示当前所属组的权限。 所以用数值表示为4+2=6 第八九十个字符“r–”表示其他用户权限。 所以用数值表示为2 所以操作此文件的权限用数值表示为662 更改权限 sudo chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录名 例如：有一个文件filename，权限为“-rw-r—-x” ,将权限值改为”-rwxrw-r-x”，用数值表示为7651sudo chmod u+x g+w o+r filename 上面的例子可以用数值表示1sudo chmod 765 filename","categories":[{"name":"Linux","slug":"Linux","permalink":"http://litzhou.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://litzhou.com/tags/Linux/"}]},{"title":"JAVA 技术学习 500G 视频教程分享","slug":"500G视频分享","date":"2017-12-23T05:59:17.000Z","updated":"2018-03-08T04:12:31.779Z","comments":true,"path":"2017/12/23/500G视频分享/","link":"","permalink":"http://litzhou.com/2017/12/23/500G视频分享/","excerpt":"Javascript视频教程JPA视频教程马士兵hibernate视频教程JAVA电子书ext4.0视频教程hadoop实战Android视频教程…","text":"Javascript视频教程JPA视频教程马士兵hibernate视频教程JAVA电子书ext4.0视频教程hadoop实战Android视频教程… 序 号 名称 地址 密码 1 javascript视频教程 http://pan.baidu.com/s/1gd57FVH d9ei 2 JPA视频教程 http://pan.baidu.com/s/1dDCx1fj fwwd 3 马士兵hibernate视频教程 http://pan.baidu.com/s/1dFILSYH nuwz 4 JAVA电子书 http://pan.baidu.com/s/1o6xlV9w 347e 5 ext4.0视频教程 http://pan.baidu.com/s/1ntvmfKd n6fi 6 hadoop实战 http://pan.baidu.com/s/1nttQoRJ r685 7 android视频教程 http://pan.baidu.com/s/1mgpi4TM tx2e 8 photoshop基础教程视频 http://pan.baidu.com/s/1eRVuN4I d9yv 9 马士兵struts2视频教程 http://pan.baidu.com/s/1qWGeCg8 m53e 10 junit视频教程 http://pan.baidu.com/s/1jGCTjQA sncp 11 SSH+Maven+EasyUI http://pan.baidu.com/s/1gfJVC8F fwmi 12 spring mvc视频教程 http://pan.baidu.com/s/1eSvBih0 5irb 13 ext视频教程 http://pan.baidu.com/s/1pLAlQRL j2dk 14 UML视频教程 http://pan.baidu.com/s/1c1AXZP2 h3ng 15 网页与UI设计从入门到精通视频教程 http://pan.baidu.com/s/1mg7z1bi w7zw 16 JSP视频教程 http://pan.baidu.com/s/1gdBDuIR jv2u 17 java邮件开发视频教程 http://pan.baidu.com/s/1o61pEgq cjm5 18 EJB视频教程 http://pan.baidu.com/s/1c05DRe4 3jdy 19 编译原理视频教程 http://pan.baidu.com/s/1mgxVZBy s6vc 20 韩顺平J2SE视频教程 http://pan.baidu.com/s/1c0x6tNy j86k 21 银行交易系统实现 http://pan.baidu.com/s/1pJL6yAv qt3m 22 黑客攻防技术见招拆招视频教程 http://pan.baidu.com/s/1hqEZgCO 1d3f 23 scm_cvs_svn视频教程 http://pan.baidu.com/s/16xQKA fmb3 24 dreamweaver教学视频 http://pan.baidu.com/s/1i3ffpGT cdy3 25 马士兵j2se http://pan.baidu.com/s/1dFlBRWX swsf 26 Unix操作系统(哈工大) http://pan.baidu.com/s/1jIx4Oo2 zgfh 27 Android开发视频教程 http://pan.baidu.com/s/1bn6vR2n yasa 28 dwr视频教程 http://pan.baidu.com/s/1bnmdj47 98bp 29 jquery视频教程 http://pan.baidu.com/s/1jGARtqe f95u 30 马士兵spring3视频教程 http://pan.baidu.com/s/1kVCvSXL ntia 31 java并发教程 http://pan.baidu.com/s/1yWqEq 4mxe 31 巴巴网开发实现 http://pan.baidu.com/s/1c0sgDSc w7z9 32 张孝详J2SE高深讲解 http://pan.baidu.com/s/1mg1ZLcG 2dg4 33 Flash动画制作教程视频 http://pan.baidu.com/s/1mirvfq4 dig7 34 C语言基础 http://pan.baidu.com/s/1dDsK8ZB b4g6 35 php视频教程 http://pan.baidu.com/s/1r4M6q w4ak 36 linux视频教程-韩顺平 http://pan.baidu.com/s/1qXIHdmO jk9k 37 spring-mvc视频教程 http://pan.baidu.com/s/1o7SU7xC fkcf 38 [吉林大学计算机操作系统视频教程] http://pan.baidu.com/s/13ad9k bux4 39 mysql特级课视频教程 http://pan.baidu.com/s/1o8O1exc 8v8b 40 NoSQL视频教程 http://pan.baidu.com/s/1c10qMbu mht2 41 maven视频教程 http://pan.baidu.com/s/1dDg9ulb 1f5k 42 JNI视频教程 http://pan.baidu.com/s/1i3tsv45 edvc 43 易语言资料与教程 http://pan.baidu.com/s/1c14S1rE ht9u 44 黑客新手综合书藉 http://pan.baidu.com/s/1mgD4VJq p4zd 45 tomcat视频教程 http://pan.baidu.com/s/1qWxhRmG kpcs 46 计算机操作系统原理视频教程 http://pan.baidu.com/s/1pJ1nEeJ vke7 47 oracle视频教程及OCP认证教程 http://pan.baidu.com/s/1o6IQDya mx1n 48 SEO网站优化视频教程-学无忧 http://pan.baidu.com/s/1i36jBcp 9gae 49 设计模式视频教程 http://pan.baidu.com/s/1kTjKUjX k7m8 50 jdbc视频教程 http://pan.baidu.com/s/1kTJCIYN hk8b 51 php从入门到精通 http://pan.baidu.com/s/1i3rq877 c792 52 html+CSS教程 http://pan.baidu.com/s/1jHPEVZK hrgd 53 JAVA编程高级知识 http://pan.baidu.com/s/1hqEtm5I yr3x 54 OA+工作流视频教程 http://pan.baidu.com/s/1mgLC9Jy 7em9 55 webservice视频教程 http://pan.baidu.com/s/1sjIe7Wp eka8 56 数据结构视频教程 http://pan.baidu.com/s/1mgElasg wtus 57 计算机网络视频教程 http://pan.baidu.com/s/1mgH8NkG 75wj 58 HTML5开发框架PhoneGap实战 http://pan.baidu.com/s/1nvyKEz3 47gn 59 SSM整合视频 http://pan.baidu.com/s/1ntEOVwt 7ibg 60 weblogic视频教程 http://pan.baidu.com/s/1bo8YojX qmy9 61 java网上在线支付实战视频 http://pan.baidu.com/s/1o6zTL4e 9kw7 62 23种设计模式视频教程 http://pan.baidu.com/s/1eQ7BD3k bhff 63 lucene视频教程 http://pan.baidu.com/s/1mgH8NlY 5g41 64 xml视频教程 http://pan.baidu.com/s/1i5kFFbJ vn86 65 HTML5入门视频教程【秀野堂】 http://pan.baidu.com/s/1sl4ciFb s46y 66 微普年薪10W版Android教学视频 http://pan.baidu.com/s/1gdJKOqn dp2i 67 ibatis视频教程 http://pan.baidu.com/s/1o6Mo4h8 jfgv 68 传智播客-韩顺平-php从入门到精通 http://pan.baidu.com/s/1c04XT9A rhuv 69 国内首部Zookeeper从入门到精通 http://pan.baidu.com/s/1dD5BOLb trv7 70 黑马ios http://pan.baidu.com/s/1ntneBJr xb3f 71 phonegap HTML5开发视频 http://pan.baidu.com/s/1boRpe5x 6ws3 72 Zookeeper入门到精通 http://pan.baidu.com/s/1ntEOV4d gtj3 73 java入门 http://pan.baidu.com/s/1bn7bLWb r5kz 74 SSH2+activiti5OA管理系统案例视频 http://pan.baidu.com/s/1gdjnfdL a54r 75 word转换 http://pan.baidu.com/s/1pJ5r14R pbvv 76 桌面UI http://pan.baidu.com/s/1sj470UL h32b 77 ajax http://pan.baidu.com/s/1kVLjw8n 38by 78 axure视频教程 http://pan.baidu.com/s/1kTD7fq3 dk89 79 兄弟连NoSQL视频教程 redis http://pan.baidu.com/s/1pJzlMt1 bjsu 80 Hadoop http://pan.baidu.com/s/1mgKqEqG rea5 81 JS视频教程 共150集 http://pan.baidu.com/s/1o6pe3t4 3cwz 82 activiti 工作流学习专题 http://pan.baidu.com/s/1o6OWoQI 7f96 83 oa http://pan.baidu.com/s/1o6laJEE 5scp 84 前段资料 http://pan.baidu.com/s/1eSmNDwI m9uk 85 简单微信[小项目] http://pan.baidu.com/s/1bnqgNSj qu4j 87 nutch http://pan.baidu.com/s/1jGsAxE2 ckjq 88 anocation http://pan.baidu.com/s/1i3HES0d cpym 89 DataGuru视频 http://pan.baidu.com/s/1kThdcMz v3sn 90 Nutch相关框架视频教程（压缩超清） http://pan.baidu.com/s/1dD2nYoT 9eb6 91 Mars《Android开发视频教程》 http://pan.baidu.com/s/1sjswhbv wdbi 92 Python http://pan.baidu.com/s/1hqrY4KG wf77 93 oa activiti 新版 http://pan.baidu.com/s/1jGMw8E6 5y4h 94 maven视频教程 http://pan.baidu.com/s/1i3g1iD3 1wik 95 linux视频教程 http://pan.baidu.com/s/1bn2Yacf k6df 96 小布老师Git入门 http://pan.baidu.com/s/1i3sCzS5 fqkb 97 Redis http://pan.baidu.com/s/1hq2hVta t7r5 98 工作流相关资料 http://pan.baidu.com/s/1o6tiskE 664u 99 EasyUI入门视频教程 http://pan.baidu.com/s/1jGxufxc 1s8m 100 MongoDB视频教程 http://pan.baidu.com/s/1pLk30d9 6jsc 101 thinkphp http://pan.baidu.com/s/1sjKg4VF 1vek","categories":[{"name":"教程","slug":"教程","permalink":"http://litzhou.com/categories/教程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/tags/Java/"},{"name":"教程","slug":"教程","permalink":"http://litzhou.com/tags/教程/"}]},{"title":"Docker 常用命令总结","slug":"Docker常用命令总结","date":"2017-12-05T13:28:48.000Z","updated":"2018-03-08T03:33:58.807Z","comments":true,"path":"2017/12/05/Docker常用命令总结/","link":"","permalink":"http://litzhou.com/2017/12/05/Docker常用命令总结/","excerpt":"构建Docker镜像1234FROM hub.c.163.com/xbingo/jdk8ADD ./app-1.0.jar /app.jarEXPOSE 80CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] FROM 基础镜像 ADD 拷贝文件到容器目录 EXPOSE 80 暴露80端口 CMD 容器内部执行的命令","text":"构建Docker镜像1234FROM hub.c.163.com/xbingo/jdk8ADD ./app-1.0.jar /app.jarEXPOSE 80CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] FROM 基础镜像 ADD 拷贝文件到容器目录 EXPOSE 80 暴露80端口 CMD 容器内部执行的命令 1docker build -t jameszhou/app:1.0 . docker build 构建Docker镜像的命令; -t jameszhou/app:1.0 要构建的镜像的名称,1.0表示镜像的tag,如不指定则使用的默认的tag latest; “.”表示Dockefile文件所在的路径，这里为当前路径，故用“.”代替; 查看镜像列表1docker images 启动容器常用两种方式12docker run -d -p 8080:80 --name app jameszhou/app:1.0 //后台运行docker run -it -p 8080:80 --name app jameszhou/app:1.0 //交互式运行 docker run 启动Docker容器命令; -d 表示后台运行; -it 以交互模式启动; -p 8080:80,将容器的80端口映射到主机的8080,注意顺序,”主机端口:容器端口”; –name app，给容器起个名字; jameszhou/app:1.0,拥有jameszhou/app这个镜像，tage为1.0，不指定tag自动找latest； 启动容器并挂载目录1docker run -d -p 8080:80 --name app -v var/lib/docker/data:/var/lib/docker/data jameszhou/app:1.0 -v 表示要挂载的目录,格式为“主机目录:容器目录”,前面的是主机目录,后面的是容器目录; 查看容器列表12docker ps docker ps -a -a 表示查看所有容器列表（包含停止的容器）,不加表示只查看正在运行的容器 启动停止的容器1docker start app docker start 启动docker容器命令; app 要启动的容器名称，这里可以是容器的Id; 查看运行日志1docker logs app 停止正在运行的容器1docker stop app docker stop 停止docker容器命令; app 要停止的容器名称，这里可以是容器的Id; 删除容器12docker rm app docker rm -f app -f表示强制删除容器，主要用于删除正在运行的容器,不加 “-f” 只能删除停止运行的容器; 进入容器SHELL1docker exec -it app bash //进入容器的shell 修改镜像名称打新的tag（修改镜像名称） 1docker tag imageid name:tag //修改镜像名称 删除镜像1docker rmi fd484f19954f //删除docker镜像 私有镜像仓库操作1234567891011121314#docker tagdocker tag 545da14ea 127.0.0.1/registry/app:1.0#登录到私有仓库docker login 127.0.0.1UserName:adminPassword:123456Email:111111@qq.com#push到私有仓库dokcer push 127.0.0.1/registry/app:1.0#从私有仓库pull一个镜像docker pull 127.0.0.1/registry/app:1.0","categories":[{"name":"Docker","slug":"Docker","permalink":"http://litzhou.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://litzhou.com/tags/Docker/"}]},{"title":"Docker 构建 SpringBoot 镜像","slug":"Docker构建SpringBoot镜像","date":"2017-12-05T13:10:55.000Z","updated":"2018-03-08T03:34:41.576Z","comments":true,"path":"2017/12/05/Docker构建SpringBoot镜像/","link":"","permalink":"http://litzhou.com/2017/12/05/Docker构建SpringBoot镜像/","excerpt":"一、构建项目使用STS构建springBoot项目 项目结构12345678910111213├─src│ ├─main│ │ ├─java│ │ │ └─com│ │ │ └─example│ │ └─resources│ │ ├─static│ │ └─templates│ └─test│ └─java│ └─com│ └─example└─target","text":"一、构建项目使用STS构建springBoot项目 项目结构12345678910111213├─src│ ├─main│ │ ├─java│ │ │ └─com│ │ │ └─example│ │ └─resources│ │ ├─static│ │ └─templates│ └─test│ └─java│ └─com│ └─example└─target pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;SpringBoot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Application.java123456789101112131415161718192021package com.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class Application &#123; @RequestMapping(\"/\") public String index()&#123; return \"Hello Docker .\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 打包项目使用maven打包项目,在target目录下得到springboot-1.0.jar1mvn clean pakcage //先清理再进行打包 run项目12345678910111213 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.1.RELEASE)......2017-02-22 13:51:45.408 INFO 1588 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-02-22 13:51:45.423 INFO 1588 --- [ main] com.example.Application : Started Application in 2.004 seconds (JVM running for 2.622)2017-02-22 13:51:58.432 INFO 1588 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;2017-02-22 13:51:58.433 INFO 1588 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started2017-02-22 13:51:58.452 INFO 1588 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 19 ms 预览地址栏输入http://localhost:8080/, 得到如下结果,项目构建成功。1Hello Docker . 二、构建Docker镜像构建Docker镜像,启动Docker容器上传springboot-1.0.jar到装有Docker服务的linux系统,这里我用的是ubutun14.04 编写Dockerfile开始编写Dockerfile文件1vi Dockerfile Dockerfile的内容，保存退出 1234FROM hub.c.163.com/xbingo/jdk8ADD ./springboot-1.0.jar /springboot.jarEXPOSE 8080CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/springboot.jar&quot;] ll查看1234567root@ubuntu:/data/test# lltotal 14004drwxr-xr-x 2 root root 4096 Feb 21 22:38 ./drwxr-xr-x 5 root root 4096 Feb 21 22:20 ../-rw-r--r-- 1 root root 124 Feb 21 22:25 Dockerfile-rw-r--r-- 1 root root 14326404 Feb 21 22:20 springboot-1.0.jarroot@ubuntu:/data/test# 构建镜像,别忘记后面的”.”,表示Dockerfile的文件位置 1234567891011121314151617root@ubuntu:/data/test# docker build -t springboot:1.0 .Sending build context to Docker daemon 14.33 MBStep 1/4 : FROM hub.c.163.com/xbingo/jdk8 ---&gt; 3273714c9663Step 2/4 : ADD ./springboot-1.0.jar /springboot.jar ---&gt; 556a8eba0f6aRemoving intermediate container 8d6a88c466e2Step 3/4 : EXPOSE 8080 ---&gt; Running in 327fc70b5fa9 ---&gt; e5e6c6b29983Removing intermediate container 327fc70b5fa9Step 4/4 : CMD java -jar /springboot.jar ---&gt; Running in 4a9c41547c8c ---&gt; c745ff82ccacRemoving intermediate container 4a9c41547c8cSuccessfully built c745ff82ccacroot@ubuntu:/data/test# 查看镜像列表,已生成springboot镜像1234root@ubuntu:/data/test# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEspringboot 1.0 c745ff82ccac 5 minutes ago 182 MBroot@ubuntu:/data/test# 运行Docker容器启动容器,并查看运行容器列表启动容器,并查看运行容器列表12345root@ubuntu:/data/test# docker run -d -p 8080:8080 --name springboot springboot:1.0840e8f08bdbbf10f3050c4c7ec38ba7c1ce90378b0f31a3a8cc7a1d2ddf66119root@ubuntu:/data/test# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES840e8f08bdbb springboot:1.0 &quot;java -jar /spring...&quot; 4 seconds ago Up 3 seconds 0.0.0.0:8080-&gt;8080/tcp springboot 预览打开宿主主机的浏览器:输入http://localhost:8080,预览效果 要想查看Docker容器日志,显示日志结果和第一步的启动日志一致1docker logs springboot","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litzhou.com/categories/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://litzhou.com/tags/Java/"},{"name":"Docker","slug":"Docker","permalink":"http://litzhou.com/tags/Docker/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://litzhou.com/tags/SpringBoot/"}]},{"title":"正在读的书","slug":"正在读的书","date":"2017-12-04T13:28:48.000Z","updated":"2018-03-08T05:22:57.516Z","comments":true,"path":"2017/12/04/正在读的书/","link":"","permalink":"http://litzhou.com/2017/12/04/正在读的书/","excerpt":"书籍 JAVA微服务实战， https://item.jd.com/12235775.html 互联网创业核心技术， https://item.jd.com/11992767.html 亿级流量网站架构核心技术，京东张开涛 https://item.jd.com/12153914.html#comment 高可用架构，案例分析 https://item.jd.com/12195481.html 尽在双十一，阿里巴巴技术演进与超越 https://item.jd.com/12152188.html 从点子到产品：产品经理的价值观与方法论 https://item.jd.com/12075352.html 人月神话 https://item.jd.com/12540387236.html 疯狂Spring Cloud微服务架构实战 https://item.jd.com/12256011.html#crumb-wrap Spring Boot 2精髓 https://item.jd.com/12214143.html vue.js 实战 https://item.jd.com/12215519.html#comment ES6标准入门（第3版） https://item.jd.com/12172449.html Python核心编程第3版 https://item.jd.com/11936238.html Python黑帽子:黑客与渗透测试编程之道 https://item.jd.com/11748995.html 黑客秘笈:渗透测试实用指南 https://item.jd.com/12046707.html 必然+失控+科技想要什么 https://item.jd.com/10274123165.html","text":"书籍 JAVA微服务实战， https://item.jd.com/12235775.html 互联网创业核心技术， https://item.jd.com/11992767.html 亿级流量网站架构核心技术，京东张开涛 https://item.jd.com/12153914.html#comment 高可用架构，案例分析 https://item.jd.com/12195481.html 尽在双十一，阿里巴巴技术演进与超越 https://item.jd.com/12152188.html 从点子到产品：产品经理的价值观与方法论 https://item.jd.com/12075352.html 人月神话 https://item.jd.com/12540387236.html 疯狂Spring Cloud微服务架构实战 https://item.jd.com/12256011.html#crumb-wrap Spring Boot 2精髓 https://item.jd.com/12214143.html vue.js 实战 https://item.jd.com/12215519.html#comment ES6标准入门（第3版） https://item.jd.com/12172449.html Python核心编程第3版 https://item.jd.com/11936238.html Python黑帽子:黑客与渗透测试编程之道 https://item.jd.com/11748995.html 黑客秘笈:渗透测试实用指南 https://item.jd.com/12046707.html 必然+失控+科技想要什么 https://item.jd.com/10274123165.html","categories":[{"name":"书籍","slug":"书籍","permalink":"http://litzhou.com/categories/书籍/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://litzhou.com/tags/书籍/"}]},{"title":"技术团队人员招聘","slug":"技术团队人员招聘","date":"2017-12-04T13:28:48.000Z","updated":"2018-03-08T05:23:11.571Z","comments":true,"path":"2017/12/04/技术团队人员招聘/","link":"","permalink":"http://litzhou.com/2017/12/04/技术团队人员招聘/","excerpt":"一、产品总监岗位职责 根据公司战略，研发技术发展路线，规划各业务产品线的技术构架； 负责各部门在各技术领域及各项目间的合作协调； 组织实施研发部工作计划，监督完成任务目标； 负责公司研发团队的梯队化建设与管理，及对核心技术人才的引进。 任职要求 熟悉产品生命周期管理理论，并有丰富的产品研发经验； 熟悉多种开发语言，精通某一种研发语言，精通常用开发模型、产品架构、实现技术； 具有优秀的开拓精神，较强的内驱力及事业心，有良好的团队协作、协调能力，具有丰富的带领研发团队经验。","text":"一、产品总监岗位职责 根据公司战略，研发技术发展路线，规划各业务产品线的技术构架； 负责各部门在各技术领域及各项目间的合作协调； 组织实施研发部工作计划，监督完成任务目标； 负责公司研发团队的梯队化建设与管理，及对核心技术人才的引进。 任职要求 熟悉产品生命周期管理理论，并有丰富的产品研发经验； 熟悉多种开发语言，精通某一种研发语言，精通常用开发模型、产品架构、实现技术； 具有优秀的开拓精神，较强的内驱力及事业心，有良好的团队协作、协调能力，具有丰富的带领研发团队经验。 二、JAVA项目经理岗位职责 负责项目计划、实施、日常管理工作，对项目成本、人员、进度、质量、风险、安全进行有效控制与管理； 负责/参与电商平台系统的架构设计、系统设计、详细设计及项目核心代码的开发工作； 编写核心代码，设计优化相关算法，指导程序员进行代码设计； 指导、培训、评价团队成员的工作； 定期向上级领导和运营管理部汇报项目执行情况，预警项目风险。 任职要求 全日制本科及以上学历毕业，计算机及相关专业； 3年以上工作经验，有1年以上项目管理经验； 至少实施过1个中型项目经验，人数超过5人； 熟练掌握J2EE相关技术，精通主流开发框架（Struts/Spring/Hibernate等）； 掌握数据库的相关知识，熟悉主流数据库应用（SQL SERVER、ORACLE等），具备较强的SQL编写能力； 具有强抗压能力和强责任心，善于积极解决及反馈问题。 7 .熟悉项目管理方法和管理工具，熟悉CMM软件能力成熟度模型。 具备较好的流程和文档编写能力，能及时高效的完成资源需求计划。 具有很好的沟通能力、业务理解能力、团队协作能力、高效执行力、项目推动能力。 拥有PMP证书者优先。 有电商项目开发经验者优先。 三、高级JAVA工程师岗位职责 根据产品需求文档完成系统架构、模块设计、编码、测试工作及性能优化； 负责/参与技术架构设计、重构、优化，根据业务规划及技术规划制定应用架构方案； 负责/参与电商平台系统的架构设计、系统设计、详细设计及项目核心代码的开发工作； 分析系统瓶颈，解决各种疑难杂症，对系统进行性能调优。 任职要求 精通Java，熟练掌握Java网络编程； 具有面向对象分析、设计、开发能力； 熟练掌握SQL语句，熟练使用数据库（MySQL、Oracle等）； 熟练使用Eclipse/Maven/Ant/SVN等软件开发工具； 可以独立设计业务逻辑架构，具有很好的模块化思想； 具有深厚的专业技术基础，精通Java EE相关技术，熟悉多种开源框架； 四、高级测试工程师岗位职责 独立负责项目系统的测试，制定测试计划和测试方案； 建立并优化测试过程,提升测试效率和产品质量； 分析测试结果，发现产品Bug并定位； 深入理解系统内部的工作原理，从测试的角度提供优化意见； 熟悉常用的测试工具和Bug管理跟踪软件。 任职要求 多年的软件开发和测试工作经验； 具备丰富的大型复杂系统软件开发和测试经验，精通性能测试、自动化测试、安全测试领域其中一种； 熟悉开源工具框架及相关扩展应用； 熟悉Linux操作系统，熟悉Oracle、Mysql等数据库。 五、高级前端工程师岗位职责 负责公司平台的前端架构设计及核心组件、框架开发； 参与制定前端技术标准及标准管理，开发符合标准高性能的网站； 主导统一前端任务，解决前端技术难题； 负责前端系统分析、优化和架构工作。 任职要求 精通各种Web前端技术（HTML/CSS/Javascript/ActionScript等)，熟练跨浏览器、跨终端的开发； 有大型网站前端架构、前端性能、可访问性、可维护性等方面的实践经验； 对HTML5有丰富的实践经验,至少熟练使用一门非前端脚本语言（NodeJS/PHP/JAVA等）； 掌握主流前端框架的源码实现，理解框架思想，可以持续改进完善业务框架。 六、高级IOS工程师岗位职责 全面负责IOS客户端产品的设计和开发； 根据产品需求能完成IOS应用的架构设计、编码、调试及发布工作； 编写产品相关的文档，优化系统。 任职要求 熟练掌握C/C++,Objective C,Swift语言； 三年以上工作经验； 熟练使用Xcode工具系列，包括Interface Builder和Instruments/Shark； 能独立完成IOS客户端应用的开发，对IOS产品开发有深入的理解； 善于沟通，有较强的学习能力和团队协作能力； 有独立完成APP开发并提交到iTunes应用商店。 七、高级Android工程师岗位职责 负责Android客户端产品的开发、设计、文档编写、调试和维护工作； 按计划完成任务，提交高质量代码； 改善系统的可用性，提升用户体验。 任职要求 三年以上Android相关开发经验； 熟练掌握JAVA语言、androidSDK使用、对面向对象编程有深入的理解； 熟练掌握Eclipse、ADT或Android Studio等相关工具的使用； 熟练掌握至少一种数据库，如MySQL； 能独立完成Android项目的设计和开发； 善于沟通，有较强的学习能力和团队协作能力； 独立完成Android开发并提交到各安卓应用商店。 八、产品经理岗位职责 市场需求调研，设计产品产品流程设计、详细功能设计文档，并监控开发过程中的需求质量； 撰写高质量的平台需求文档与平台原型图； 管理跟踪平台的体验效果数据，改善产品和用户体验； 协调和处理产品日常各类用户反馈问题，包括使用意见、故障处理、数据分析任务等； 各部门的沟通与跟踪开发进度。 任职要求 在互联网/通信产品经历不少于2年，大专学历以上，设计类或计算机专业优先； 能独立完成需求分析和需求管理工作，并提出策划方案；执行力强，善于组织协调并推动项目进展； 热爱互联网，有电商产品经验者优先。 九、高级UI工程师岗位职责 负责网站软件界面设计、移动App界面设计，及界面相关图片图标、动画等制作工作； 负责公司产品宣传册、折页、名片,海报等平面设计制作工作； 能够跟需求沟通，完成设计，清晰展现出客户阐述设计理念，获得客户认可； 配合产品、项目进度完成设计工作，适时对相关业务开展提出视觉、体验方面的建议； 任职要求 统招大专及以上学历，平面设计、网页设计等设计类相关专业； 具备一年以上对pc端和web端视觉设计相关工作经验，能够独立完成产品前期设计风格； 熟悉当前的网站设计形式，有良好的视觉设计能力，有优秀的布局感和色彩感，能够整体把握网站的风格和结构； 对排版、色彩、设计布局和ui设计有深入的理解，美术设计及计算机相关专业或者培训班培训过者优先； 熟练操作Photoshop、illustrator、Axure、arcgis,等软件工具,并且熟悉常用的office办公软件； 思维逻辑强、主动性好、学习能力强者优先,具有良好的沟通与表达能力和主动学习能力以及团队合作精神。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://litzhou.com/categories/项目管理/"}],"tags":[{"name":"招聘","slug":"招聘","permalink":"http://litzhou.com/tags/招聘/"}]},{"title":"APP项目开发的一般流程","slug":"APP项目开发的一般流程","date":"2017-12-03T13:28:48.000Z","updated":"2018-03-08T05:23:25.395Z","comments":true,"path":"2017/12/03/APP项目开发的一般流程/","link":"","permalink":"http://litzhou.com/2017/12/03/APP项目开发的一般流程/","excerpt":"APP项目开发的一般流程1.需求分析 初步画出项目功能结构图 组织业务部门开会确定需求 根据会议讨论结果修改项目功能 评估开发周期 编写开发文档","text":"APP项目开发的一般流程1.需求分析 初步画出项目功能结构图 组织业务部门开会确定需求 根据会议讨论结果修改项目功能 评估开发周期 编写开发文档 2.原型设计 产品经理参考需求文档、功能结构图和会议纪要设计软件原型 原型设计好之后和业务部门、开发部门开会再次确定原型是否合理 综合以上意见作出原型改进，定稿，进行UI设计 3.UI设计 设计师设计出APP的LOGO，包括上架各个平台所需尺寸的图标 规定软件风格,包括主色调、字体、信息风格、警告风格、错误风格等 4.开发4.1 数据库设计 后端开发人员设计出数据库，导出数据库脚本 4.2 APP接口开发 后端技术经理选择合适的语言搭建后台框架，为方便我后期维护，请选择JAVA语言 制订开发规范，如：类、方法、变量等命名规格，注释 组织1-2人开发接口 4.3 平台端后台管理系统开发 在APP框架开发规范的基础上进行开发 4.4 商家端后台管理系统开发 在APP框架开发规范的基础上进行开发 4.5 支付接口对接开发 开发人员在微信、支付宝开发者中心注册账号，申请接口 第三方支付平台审核通过后与APP进行对接开发 第三方支付平台审核一般3-7天，请预留时间 4.6 Android端开发 Android技术经理搭建框架，制订开发规范 团队分工开发Android客户端 4.7 IOS端开发 IOS开发经理搭建框架，制订开发规范 团队分工开发IOS客户端 4.8 WAP端开发 前端工程师搭建WAP端框架，制订开发规范 团队分工开发WAP端 5.测试5.1 Android端测试、修改BUG 测试工程师测试Android客户端,提交BUG Android工程师修改BUG 5.2 IOS端测试、修改BUG 测试工程师测试IOS客户端,提交BUG IOS工程师修改BUG 5.3 WAP端测试、修改BUG 测试工程师测试WAP客户端,提交BUG 前端工程师修改BUG” 6.4 其他 测试工程师测试平台端后台 测试工程师测试商家端后台 6.发布6.1 发布Android端 发布Android客户端到各大应用市场 发布资质需要提前注册账号，审核需要3-5天 6.2 发布IOS端 在AppStore发布IOS客户端 需要提前注册账号，审核需要7-15天 另外IOS开发者账号是收费的，需要申请一笔费用 6.3 发布WAP端 前端工程师发布WAP端 6.4 发布后台项目 后端工程师发布后台项目 7.维护 运维工程师监控项目运行状况，发现问题及时反馈给相关人员解决","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://litzhou.com/categories/项目管理/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://litzhou.com/tags/项目管理/"}]},{"title":"史上最全 Html 和 CSS 布局技巧","slug":"史上最全Html和CSS布局技巧","date":"2017-12-03T01:41:50.000Z","updated":"2018-03-08T03:36:31.360Z","comments":true,"path":"2017/12/03/史上最全Html和CSS布局技巧/","link":"","permalink":"http://litzhou.com/2017/12/03/史上最全Html和CSS布局技巧/","excerpt":"单列布局水平居中水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法。注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素","text":"单列布局水平居中水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法。注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素 使用inline-block 和 text-align实现12.parent&#123;text-align: center;&#125;.child&#123;display: inline-block;&#125; 优点：兼容性好；不足：需要同时设置子元素和父元素 使用margin:0 auto来实现1.child&#123;width:200px;margin:0 auto;&#125; 优点：兼容性好缺点: 需要指定宽度 使用table实现1.child&#123;display:table;margin:0 auto;&#125; 优点:只需要对自身进行设置不足:IE6,7需要调整结构 使用绝对定位实现123.parent&#123;position:relative;&#125;/*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/.child&#123;position:absolute;left:50%;transform:translate(-50%);&#125; 不足：兼容性差,IE9及以上可用 实用flex布局实现12345/*第一种方法*/.parent&#123;display:flex;justify-content:center;&#125;/*第二种方法*/.parent&#123;display:flex;&#125;.child&#123;margin:0 auto;&#125; 缺点：兼容性差，如果进行大面积的布局可能会影响效率 垂直居中vertical-align我们都知道，每个人都有不同的嗜好，有的人喜欢吃甜食，有的人喜欢吃辣的东西，有的人不喜欢吃芹菜，有的人不喜欢吃羊肉等等。CSS中的有些元素也是这样，他们有的只对牛奶感兴趣，有的只喜欢吃坚果和果冻，而讨厌牛奶。而vertical-align呢，是个比较挑食的家伙，它只喜欢吃果冻，从小吃果冻长大，没有了果冻，它就会闹脾气，对你不理不睬。我称之为“果冻依赖型元素”，又称之为“inline-block依赖型元素”，也就是说,只有一个元素属于inline或是inline-block（table-cell也可以理解为inline-block水平）水平，其身上的vertical-align属性才会起作用。我对css-vertical-align的一些理解与认识在使用vertical-align的时候，由于对齐的基线是用行高的基线作为标记，故需要设置line-height或设置display:table-cell;1234/*第一种方法*/.parent&#123;display:table-cell;vertical-align:middle;height:20px;&#125;/*第二种方法*/.parent&#123;display:inline-block;vertical-align:middle;line-height:20px;&#125; 实用绝对定位12.parent&#123;position:relative;&#125;.child&#123;positon:absolute;top:50%;transform:translate(0,-50%);&#125; 实用flex实现1.parent&#123;display:flex;align-items:center;&#125; 水平垂直全部居中利用vertical-align,text-align,inline-block实现12.parent&#123;display:table-cell;vertical-align:middle;text-align:center;&#125;.child&#123;display:inline-block;&#125; 利用绝对定位实现12.parent&#123;position:relative;&#125;.child&#123;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);&#125; 利用flex实现1.parent&#123;display:flex;justify-content:center;align-items:center;&#125; 多列布局左列定宽，右列自适应该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局图片描述 利用float+margin实现12.left&#123;float:left;width:100px;&#125;.right&#123;margin-left;margin-left:100px;&#125; 注：IE6会有3px的bug 利用float+margin(fix)实现图片描述123456&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123.left&#123;width:100px;float:left;&#125;.right-fix&#123;width:100%;margin-left:-100px;float:right;&#125;.right&#123;margin-left:100px;&#125; 使用float+overflow实现12.left&#123;width:100px;float:left;&#125;.right&#123;overflow:hidden;&#125; overflow:hidden，触发bfc模式，浮动无法影响，隔离其他元素，IE6不支持，左侧left设置margin-left当作left与right之间的边距，右侧利用overflow:hidden 进行形成bfc模式如果我们需要将两列设置为等高，可以用下述方法将“背景”设置为等高，其实并不是内容的等高1234.left&#123;width:100px;float:left;&#125;.right&#123;overflow:hidden;&#125;.parent&#123;overflow:hidden;&#125;.left,.right&#123;padding-bottom:9999px;margin-bottom:-9999px;&#125; 使用table实现123.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.left&#123;width:100px;&#125;.right,.left&#123;display:table-cell;&#125; 使用flex实现123.parent&#123;display:flex;&#125;.left&#123;width:100px;&#125;.right&#123;flex:1;&#125; 利用右侧容器的flex:1，均分了剩余的宽度，也实现了同样的效果。而align-items 默认值为stretch，故二者高度相等 右列定宽，左列自适应实用float+margin实现123.parent&#123;background:red;height:100px;margin:0 auto;&#125;.left&#123;background:green;margin-right:-100px;width:100%;float:left;&#125;.right&#123;float:right;width:100px;background:blue;&#125; 使用table实现123.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.left&#123;display:table-cell;&#125;.right&#123;width:100px;display:table-cell;&#125; 实用flex实现123.parent&#123;display:flex;&#125;.left&#123;flex:1;&#125;.right&#123;width:100px;&#125; 两列定宽，一列自适应图片描述基本html结构为父容器为parent,自容器为left,center,right.其中，left,center定宽，right自适应 利用float+margin实现12.left,.center&#123;float:left:width:200px;&#125;.right&#123;margin-left:400px;&#125; 利用float+overflow实现12.left,.center&#123;float:left:width:200px;&#125;.right&#123;overflow:hidden;&#125; 利用table实现123.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.left,.center,.right&#123;display:table-cell;&#125;.left,.center&#123;width:200px;&#125; 利用flex实现123.parent&#123;display:flex;&#125;.left,.center&#123;width:100px;&#125;.right&#123;flex:1&#125; 两侧定宽，中栏自适应图片描述 利用float+margin实现123.left&#123;width：100px;float:left;&#125;.center&#123;float:left;width:100%;margin-right:-200px;&#125;.right&#123;width:100px;float:right;&#125; 利用table实现1234.parent&#123;width:100%;display:table;table-layout:fixed&#125;.left,.center,.right&#123;display:table-cell;&#125;.left&#123;width:100px;&#125;.right&#123;width:100px;&#125; 利用flex实现1234.parent&#123;display:flex;&#125;.left&#123;width:100px;&#125;.center&#123;flex:1;&#125;.right&#123;width:100px;&#125; 一列不定宽，一列自适应图片描述 利用float+overflow实现12.left&#123;float:left;&#125;.right&#123;overflow:hidden;&#125; 利用table实现123.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.left&#123;width:0.1%;&#125;.left,.right&#123;display:table-cell;&#125; 利用flex实现12.parent&#123;display:flex;&#125;.right&#123;flex:1;&#125; 多列等分布局多列等分布局常出现在内容中，多数为功能的，同阶级内容的并排显示等。图片描述html结构如下所示123456&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt;&lt;/div&gt; 实用float实现12.parent&#123;margin-left:-20px&#125;/*假设列之间的间距为20px*/.column&#123;float:left;width:25%;padding-left:20px;box-sizing:border-box;&#125; 利用table实现123.parent-fix&#123;margin-left:-20px;&#125;.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.column&#123;display:table-cell;padding-left:20px;&#125; 利用flex实现123.parent&#123;display:flex;&#125;.column&#123;flex:1;&#125;.column+.column&#123;margin-left:20px;&#125; 九宫格布局###使用table实现12345&lt;div class=\"parent\"&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; 123.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.row&#123;display:table-row;&#125;.item&#123;display:table-cell;width:33.3%;height:200px;&#125; 实用flex实现12345&lt;div class=\"parent\"&gt;&lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 123.parent&#123;display:flex;flex-direction:column;&#125;.row&#123;height:100px;display:flex;&#125;.item&#123;width:100px;background:red;&#125; 全屏布局图片描述 利用绝对定位实现123456&lt;div class=\"parent\"&gt;&lt;div class=\"top\"&gt;top&lt;/div&gt;&lt;div class=\"left\"&gt;left&lt;/div&gt;&lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;div class=\"bottom\"&gt;bottom&lt;/div&gt;&lt;/div&gt; 12345html,body,parent&#123;height:100%;overflow:hidden;&#125;.top&#123;position:absolute:top:0;left:0;right:0;height:100px;&#125;.left&#123;position:absolute;top:100px;left:0;bottom:50px;width:200px;&#125;.right&#123;position:absolute;overflow:auto;left:200px;right:0;top:100px;bottom:50px;&#125;.bottom&#123;position:absolute;left:0;right:0;bottom:0;height:50px;&#125; 利用flex实现12345678&lt;div class=\"parent\"&gt;&lt;div class=\"top\"&gt;top&lt;/div&gt;&lt;div class=\"middle\"&gt;&lt;div class=\"left\"&gt;left&lt;/div&gt;&lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;bottom&lt;/div&gt;&lt;/div&gt; 123456.parent&#123;display:flex;flex-direction:column;&#125;.top&#123;height:100px;&#125;.bottom&#123;height:50px;&#125;.middle&#123;flex:1;display:flex;&#125;.left&#123;width:200px;&#125;.right&#123;flex:1;overflow:auto;&#125; 响应式布局meta标签的实用设置布局宽度等于设备宽度，布局viewport等于度量viewport1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; 媒体查询HTML 4和CSS 2目前支持为不同的媒体类型设定专有的样式表, 比如, 一个页面在屏幕上显示时使用无衬线字体,而在打印时则使用衬线字体, screen 和 print 是两种已定义的媒体类型, 媒体查询让样式表有更强的针对性,扩展了媒体类型的功能;媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成,媒体查询中可用于检测的媒体特性有width、height和color（等）, 使用媒体查询, 可以在不改变页面内容的情况下,为特定的一些输出设备定制显示效果。 语法1@media screen and (max-width:960px)&#123;....&#125; 作者：mrshi原文地址：http://segmentfault.com/a/1190000003931851 作者： GD_SeHun链接：http://www.imooc.com/article/2235来源：慕课网","categories":[{"name":"CSS","slug":"CSS","permalink":"http://litzhou.com/categories/CSS/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://litzhou.com/tags/Html/"},{"name":"CSS","slug":"CSS","permalink":"http://litzhou.com/tags/CSS/"}]}]}